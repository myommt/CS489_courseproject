spring.application.name=dentalsurgeryapp
server.port=8083

# --- H2 in-memory DB for local testing ---
#spring.datasource.url=jdbc:mysql://localhost:3306/apsd489
#spring.datasource.username=root
#spring.datasource.password=Abcde12345!
 
spring.datasource.url=jdbc:mysql://dentalsurgeryappdb.mysql.database.azure.com:3306/apsd489?useSSL=true&requireSSL=true&verifyServerCertificate=true&serverSslCert=classpath:DigiCertGlobalRootG2.crt.pem
spring.datasource.username=myoAdmin1
spring.datasource.password=Abcde12345!

# Explicit driver (optional, usually auto-detected)
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# If your environment doesn't trust the DigiCert root by default, create a Java truststore
# from the provided certificate `DigiCertGlobalRootG2.crt.pem` and pass JVM args when
# running the app (example):
#
#   -Djavax.net.ssl.trustStore=src/main/resources/azure-truststore.jks \
#   -Djavax.net.ssl.trustStorePassword=changeit
#
# To create the truststore (run locally once):
#
#   keytool -importcert -alias digicert-global-root-g2 -file src/main/resources/DigiCertGlobalRootG2.crt.pem \
#     -keystore src/main/resources/azure-truststore.jks -storepass changeit -noprompt
#
# For production, store the truststore securely (not in source control) and use a secure password.

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=false

# Use camelCase for column names instead of snake_case
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# SQL init: temporarily enable to load jim.b user
spring.sql.init.mode=never

# H2 console
#spring.h2.console.enabled=true
#spring.h2.console.path=/h2-console

## Server
# Port changed to 8082 temporarily

# Hide Hibernate SQL logs completely
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF

# ------------------------------------------------------------------
# Alternate example (user suggested) â€” notes and sample configuration:
# - `serverSslCert` must point to a certificate file path accessible by the JVM
#   (absolute or relative filesystem path). `classpath:` values are NOT supported
#   directly by the connector. If you keep the certificate on the classpath you
#   must extract it at runtime to a temp file or use a Java truststore (recommended).
# - Ensure the username is in the form `username@servername` for Azure MySQL.
#
# Example A - use serverSslCert (certificate file on disk):
# spring.datasource.url=jdbc:mysql://dentalsurgeryappdb.mysql.database.azure.com:3306/apsd489?useSSL=true&requireSSL=true&verifyServerCertificate=true&serverSslCert=C:\\path\\to\\DigiCertGlobalRootG2.crt.pem
# spring.datasource.username=myoAdmin1@dentalsurgeryappdb
# spring.datasource.password=YourPasswordHere
# spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#
# Example B - recommended (truststore + sslMode=VERIFY_CA):
# Keep the default `sslMode=VERIFY_CA` in `spring.datasource.url` and import
# `DigiCertGlobalRootG2.crt.pem` into a Java truststore; then run the JVM with:
#
#   -Djavax.net.ssl.trustStore=src/main/resources/azure-truststore.jks \
#   -Djavax.net.ssl.trustStorePassword=changeit
#
# See `docs/azure-mysql-setup.md` for commands and notes.
# ------------------------------------------------------------------
